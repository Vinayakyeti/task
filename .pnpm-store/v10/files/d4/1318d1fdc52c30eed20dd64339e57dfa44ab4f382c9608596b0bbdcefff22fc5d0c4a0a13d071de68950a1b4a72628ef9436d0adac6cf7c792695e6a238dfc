{"version":3,"sources":["../../src/queries/buildSearchParams.ts"],"sourcesContent":["import type { FilterQuery } from 'mongoose'\nimport type { FlattenedField, Operator, PathToQuery, Payload } from 'payload'\n\nimport { Types } from 'mongoose'\nimport { APIError, getLocalizedPaths } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { MongooseAdapter } from '../index.js'\nimport type { OperatorMapKey } from './operatorMap.js'\n\nimport { getCollection } from '../utilities/getEntity.js'\nimport { operatorMap } from './operatorMap.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\ntype SearchParam = {\n  path?: string\n  rawQuery?: unknown\n  value?: unknown\n}\n\nconst subQueryOptions = {\n  lean: true,\n  limit: 50,\n}\n\n/**\n * Convert the Payload key / value / operator into a MongoDB query\n */\nexport async function buildSearchParam({\n  collectionSlug,\n  fields,\n  globalSlug,\n  incomingPath,\n  locale,\n  operator,\n  parentIsLocalized,\n  payload,\n  val,\n}: {\n  collectionSlug?: string\n  fields: FlattenedField[]\n  globalSlug?: string\n  incomingPath: string\n  locale?: string\n  operator: string\n  parentIsLocalized: boolean\n  payload: Payload\n  val: unknown\n}): Promise<SearchParam | undefined> {\n  // Replace GraphQL nested field double underscore formatting\n  let sanitizedPath = incomingPath.replace(/__/g, '.')\n  if (sanitizedPath === 'id') {\n    sanitizedPath = '_id'\n  }\n\n  let paths: PathToQuery[] = []\n\n  let hasCustomID = false\n\n  if (sanitizedPath === '_id') {\n    const customIDFieldType = collectionSlug\n      ? payload.collections[collectionSlug]?.customIDType\n      : undefined\n\n    let idFieldType: 'number' | 'text' = 'text'\n\n    if (customIDFieldType) {\n      idFieldType = customIDFieldType\n      hasCustomID = true\n    }\n\n    paths.push({\n      collectionSlug,\n      complete: true,\n      field: {\n        name: 'id',\n        type: idFieldType,\n      } as FlattenedField,\n      parentIsLocalized: parentIsLocalized ?? false,\n      path: '_id',\n    })\n  } else {\n    paths = getLocalizedPaths({\n      collectionSlug,\n      fields,\n      globalSlug,\n      incomingPath: sanitizedPath,\n      locale,\n      parentIsLocalized,\n      payload,\n    })\n  }\n\n  if (!paths[0]) {\n    return undefined\n  }\n\n  const [{ field, path }] = paths\n  if (path) {\n    const sanitizedQueryValue = sanitizeQueryValue({\n      field,\n      hasCustomID,\n      locale,\n      operator,\n      parentIsLocalized,\n      path,\n      payload,\n      val,\n    })\n\n    if (!sanitizedQueryValue) {\n      return undefined\n    }\n\n    const { operator: formattedOperator, rawQuery, val: formattedValue } = sanitizedQueryValue\n\n    if (rawQuery) {\n      return { value: rawQuery }\n    }\n\n    if (!formattedOperator) {\n      return undefined\n    }\n\n    // If there are multiple collections to search through,\n    // Recursively build up a list of query constraints\n    if (paths.length > 1) {\n      // Remove top collection and reverse array\n      // to work backwards from top\n      const pathsToQuery = paths.slice(1).reverse()\n\n      let relationshipQuery: SearchParam = {\n        value: {},\n      }\n\n      for (const [i, { collectionSlug, path: subPath }] of pathsToQuery.entries()) {\n        if (!collectionSlug) {\n          throw new APIError(`Collection with the slug ${collectionSlug} was not found.`)\n        }\n\n        const { Model: SubModel } = getCollection({\n          adapter: payload.db as MongooseAdapter,\n          collectionSlug,\n        })\n\n        if (i === 0) {\n          const subQuery = await SubModel.buildQuery({\n            locale,\n            payload,\n            where: {\n              [subPath]: {\n                [formattedOperator]: val,\n              },\n            },\n          })\n\n          const result = await SubModel.find(subQuery, subQueryOptions)\n\n          const $in: unknown[] = []\n\n          result.forEach((doc) => {\n            const stringID = doc._id.toString()\n            $in.push(stringID)\n\n            if (Types.ObjectId.isValid(stringID)) {\n              $in.push(doc._id)\n            }\n          })\n\n          if (pathsToQuery.length === 1) {\n            return {\n              path,\n              value: { $in },\n            }\n          }\n\n          const nextSubPath = pathsToQuery[i + 1]?.path\n\n          if (nextSubPath) {\n            relationshipQuery = { value: { [nextSubPath]: $in } }\n          }\n\n          continue\n        }\n\n        const subQuery = relationshipQuery.value as FilterQuery<any>\n        const result = await SubModel.find(subQuery, subQueryOptions)\n\n        const $in = result.map((doc) => doc._id)\n\n        // If it is the last recursion\n        // then pass through the search param\n        if (i + 1 === pathsToQuery.length) {\n          relationshipQuery = {\n            path,\n            value: { $in },\n          }\n        } else {\n          relationshipQuery = {\n            value: {\n              _id: { $in },\n            },\n          }\n        }\n      }\n\n      return relationshipQuery\n    }\n\n    if (formattedOperator && validOperatorSet.has(formattedOperator as Operator)) {\n      const operatorKey = operatorMap[formattedOperator as OperatorMapKey]\n\n      if (field.type === 'relationship' || field.type === 'upload') {\n        let hasNumberIDRelation\n        let multiIDCondition = '$or'\n        if (operatorKey === '$ne') {\n          multiIDCondition = '$and'\n        }\n\n        const result = {\n          value: {\n            [multiIDCondition]: [{ [path]: { [operatorKey]: formattedValue } }],\n          },\n        }\n\n        if (typeof formattedValue === 'string') {\n          if (Types.ObjectId.isValid(formattedValue)) {\n            result.value[multiIDCondition]?.push({\n              [path]: { [operatorKey]: new Types.ObjectId(formattedValue) },\n            })\n          } else {\n            ;(Array.isArray(field.relationTo) ? field.relationTo : [field.relationTo]).forEach(\n              (relationTo) => {\n                const isRelatedToCustomNumberID =\n                  payload.collections[relationTo]?.customIDType === 'number'\n\n                if (isRelatedToCustomNumberID) {\n                  hasNumberIDRelation = true\n                }\n              },\n            )\n\n            if (hasNumberIDRelation) {\n              result.value[multiIDCondition]?.push({\n                [path]: { [operatorKey]: parseFloat(formattedValue) },\n              })\n            }\n          }\n        }\n\n        const length = result.value[multiIDCondition]?.length\n\n        if (typeof length === 'number' && length > 1) {\n          return result\n        }\n      }\n\n      if (formattedOperator === 'like' && typeof formattedValue === 'string') {\n        const words = formattedValue.split(' ')\n\n        const result = {\n          value: {\n            $and: words.map((word) => ({\n              [path]: {\n                $options: 'i',\n                $regex: word.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n              },\n            })),\n          },\n        }\n\n        return result\n      }\n\n      if (formattedOperator === 'not_like' && typeof formattedValue === 'string') {\n        const words = formattedValue.split(' ')\n\n        const result = {\n          value: {\n            $and: words.map((word) => ({\n              [path]: {\n                $not: {\n                  $options: 'i',\n                  $regex: word.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'),\n                },\n              },\n            })),\n          },\n        }\n\n        return result\n      }\n\n      // Some operators like 'near' need to define a full query\n      // so if there is no operator key, just return the value\n      if (!operatorKey) {\n        return {\n          path,\n          value: formattedValue,\n        }\n      }\n\n      return {\n        path,\n        value: { [operatorKey]: formattedValue },\n      }\n    }\n  }\n  return undefined\n}\n"],"names":["Types","APIError","getLocalizedPaths","validOperatorSet","getCollection","operatorMap","sanitizeQueryValue","subQueryOptions","lean","limit","buildSearchParam","collectionSlug","fields","globalSlug","incomingPath","locale","operator","parentIsLocalized","payload","val","sanitizedPath","replace","paths","hasCustomID","customIDFieldType","collections","customIDType","undefined","idFieldType","push","complete","field","name","type","path","sanitizedQueryValue","formattedOperator","rawQuery","formattedValue","value","length","pathsToQuery","slice","reverse","relationshipQuery","i","subPath","entries","Model","SubModel","adapter","db","subQuery","buildQuery","where","result","find","$in","forEach","doc","stringID","_id","toString","ObjectId","isValid","nextSubPath","map","has","operatorKey","hasNumberIDRelation","multiIDCondition","Array","isArray","relationTo","isRelatedToCustomNumberID","parseFloat","words","split","$and","word","$options","$regex","$not"],"mappings":"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"}